function T(e,t){for(var r=0;r<t.length;r++){const n=t[r];if(typeof n!="string"&&!Array.isArray(n)){for(const a in n)if(a!=="default"&&!(a in e)){const o=Object.getOwnPropertyDescriptor(n,a);o&&Object.defineProperty(e,a,o.get?o:{enumerable:!0,get:()=>n[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var l=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function P(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var y={exports:{}};y.exports;var b;function v(){return b||(b=1,function(e){typeof self<"u"&&(e.window=self),typeof window<"u"&&(e.window=window);var t=e.window||e,r,n=t.SEA||{};(n.window=e.window)&&(n.window.SEA=n);try{r+""!=typeof MODULE&&(MODULE.exports=n)}catch{}e.exports=n}(y)),y.exports}function p(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var A={},S;function O(){if(S)return A;S=1;var e;if(e+""==typeof btoa){if(e+""==typeof Buffer)try{l.Buffer=p("buffer",1).Buffer}catch{console.log("Please `npm install buffer` or add it to your package.json !")}l.btoa=function(t){return Buffer.from(t,"binary").toString("base64")},l.atob=function(t){return Buffer.from(t,"base64").toString("binary")}}return A}var g,E;function R(){if(E)return g;E=1,O();function e(){}return Object.assign(e,{from:Array.from}),e.prototype=Object.create(Array.prototype),e.prototype.toString=function(t,r,n){t=t||"utf8",r=r||0;const a=this.length;if(t==="hex"){const o=new Uint8Array(this);return[...Array((n&&n+1||a)-r).keys()].map(i=>o[i+r].toString(16).padStart(2,"0")).join("")}if(t==="utf8")return Array.from({length:(n||a)-r},(o,i)=>String.fromCharCode(this[i+r])).join("");if(t==="base64")return btoa(this)},g=e,g}var w,k;function U(){if(k)return w;k=1,O();var e=R();function t(...r){return console.warn("new SafeBuffer() is depreciated, please use SafeBuffer.from()"),t.from(...r)}return t.prototype=Object.create(Array.prototype),Object.assign(t,{from(){if(!Object.keys(arguments).length||arguments[0]==null)throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");const r=arguments[0];let n;if(typeof r=="string"){const o=arguments[1]||"utf8";if(o==="hex"){const i=r.match(/([\da-fA-F]{2})/g).map(u=>parseInt(u,16));if(!i||!i.length)throw new TypeError("Invalid first argument for type 'hex'.");n=e.from(i)}else if(o==="utf8"||o==="binary"){const i=r.length,u=new Uint16Array(i);Array.from({length:i},(f,s)=>u[s]=r.charCodeAt(s)),n=e.from(u)}else if(o==="base64"){const i=atob(r),u=i.length,f=new Uint8Array(u);Array.from({length:u},(s,c)=>f[c]=i.charCodeAt(c)),n=e.from(f)}else o==="binary"?n=e.from(r):console.info("SafeBuffer.from unknown encoding: "+o);return n}if(r.byteLength,r.byteLength?r.byteLength:r.length){let o;return r instanceof ArrayBuffer&&(o=new Uint8Array(r)),e.from(o||r)}},alloc(r,n=0){return e.from(new Uint8Array(Array.from({length:r},()=>n)))},allocUnsafe(r){return e.from(new Uint8Array(Array.from({length:r})))},concat(r){if(!Array.isArray(r))throw new TypeError("First argument must be Array containing ArrayBuffer or Uint8Array instances.");return e.from(r.reduce((n,a)=>n.concat(Array.from(a)),[]))}}),t.prototype.from=t.from,t.prototype.toString=e.prototype.toString,w=t,w}var d,x;function C(){if(x)return d;x=1;const e=v(),t={Buffer:U()};var r={},n;if(JSON.parseAsync=JSON.parseAsync||function(o,i,u){var f;try{i(f,JSON.parse(o,u))}catch(s){i(s)}},JSON.stringifyAsync=JSON.stringifyAsync||function(o,i,u,f){var s;try{i(s,JSON.stringify(o,u,f))}catch(c){i(c)}},t.parse=function(o,i){return new Promise(function(u,f){JSON.parseAsync(o,function(s,c){s?f(s):u(c)},i)})},t.stringify=function(o,i,u){return new Promise(function(f,s){JSON.stringifyAsync(o,function(c,D){c?s(c):f(D)},i,u)})},e.window&&(t.crypto=e.window.crypto||e.window.msCrypto,t.subtle=(t.crypto||r).subtle||(t.crypto||r).webkitSubtle,t.TextEncoder=e.window.TextEncoder,t.TextDecoder=e.window.TextDecoder,t.random=o=>t.Buffer.from(t.crypto.getRandomValues(new Uint8Array(t.Buffer.alloc(o))))),!t.TextDecoder){const{TextEncoder:o,TextDecoder:i}=p((n+""==typeof MODULE?".":"")+"./lib/text-encoding");t.TextDecoder=i,t.TextEncoder=o}if(!t.crypto)try{var a=p("crypto",1);Object.assign(t,{crypto:a,random:i=>t.Buffer.from(a.randomBytes(i))});const{Crypto:o}=p("@peculiar/webcrypto",1);t.ossl=t.subtle=new o({directory:"ossl"}).subtle}catch{console.log("Please `npm install @peculiar/webcrypto` or add it to your package.json !")}return d=t,d}var m,j;function _(){if(j)return m;j=1;var e=v(),t=C(),r={};return r.pbkdf2={hash:{name:"SHA-256"},iter:1e5,ks:64},r.ecdsa={pair:{name:"ECDSA",namedCurve:"P-256"},sign:{name:"ECDSA",hash:{name:"SHA-256"}}},r.ecdh={name:"ECDH",namedCurve:"P-256"},r.jwk=function(n,a){n=n.split(".");var o=n[0],i=n[1],u={kty:"EC",crv:"P-256",x:o,y:i,ext:!0};return u.key_ops=a?["sign"]:["verify"],a&&(u.d=a),u},r.keyToJwk=function(n){return{kty:"oct",k:n.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,""),ext:!1,alg:"A256GCM"}},r.recall={validity:12*60*60,hook:function(n){return n}},r.check=function(n){return typeof n=="string"&&n.slice(0,4)==="SEA{"},r.parse=async function(a){try{var o=typeof a=="string";return o&&a.slice(0,4)==="SEA{"&&(a=a.slice(3)),o?await t.parse(a):a}catch{}return a},e.opt=r,m=r,m}var h,B;function K(){if(B)return h;B=1;var e=v(),t=C();return _(),e.name=e.name||(async(r,n)=>{try{if(r)try{r()}catch(a){console.log(a)}return}catch(a){if(console.log(a),e.err=a,e.throw)throw a;r&&r();return}}),e.pair=e.pair||(async(r,n)=>{try{var a=t.ossl||t.subtle,o=await t.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]).then(async f=>{var s={};s.priv=(await t.subtle.exportKey("jwk",f.privateKey)).d;var c=await t.subtle.exportKey("jwk",f.publicKey);return s.pub=c.x+"."+c.y,s});try{var i=await a.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"]).then(async f=>{var s={};s.epriv=(await a.exportKey("jwk",f.privateKey)).d;var c=await a.exportKey("jwk",f.publicKey);return s.epub=c.x+"."+c.y,s})}catch(f){if(e.window)throw f;if(f=="Error: ECDH is not a supported algorithm")console.log("Ignoring ECDH...");else throw f}i=i||{};var u={pub:o.pub,priv:o.priv,epub:i.epub,epriv:i.epriv};if(r)try{r(u)}catch(f){console.log(f)}return u}catch(f){if(console.log(f),e.err=f,e.throw)throw f;r&&r();return}}),h=e.pair,h}var q=K();const J=P(q),N=T({__proto__:null,default:J},[q]);export{N as p};
